<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        h1 {
            color: red;
        }

        pre {
            margin-left: 20px;
        }

        .row {
            display: flex;
            flex-direction: row;
        }
        ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
  border:#979595;
}

li {
  float: left;
  border-right:1px solid #bbb;
}

li:last-child {
  border-right: none;
}

li a {
  display: block;
  color: rgb(0, 0, 0);
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

li a:hover:not(.active) {
  background-color: #979595;
}

.active {
  background-color: #9fa1a0;
}

    </style>
</head>

<body>
    <ul>
        <li><a href="index.html">Exp1</a></li>
        <li><a href="exp2.html">Exp2</a></li>
        <li><a href="exp3.html">Exp3</a></li>
        <li ><a href="exp4.html">Exp4</a></li>
        <li><a href="exp5.html">Exp5</a></li>
        <li><a href="exp6.html">Exp6</a></li>
        <li><a href="exp7.html">Exp7</a></li>
        <li ><a href="exp8.html">Exp8</a></li>
        <li><a href="exp9.html">Exp9</a></li>
        <li><a class="active" href="exp10.html">Exp10</a></li>
        <li><a href="exp11.html">Exp11</a></li>
        <li ><a href="exp12.html">Exp12</a></li>
        <li><a href="exp13.html">Exp13</a></li>
        
      </ul>
    <hr>
    <div class=row>
        <div class="col-1">
            <pre>
     
    Aim: Implementation of traversal of a directed graph through BFS and DFS
    Code:
    BFS:
    #include stdio.h
    int a[20][20],q[20],visited[20],n,f=-1,r=-1;
    void bfs(int v)
    {
    int i;
    for (i=0;i&lt;n;i++) 
    {
    if(a[v][i] != 0 && visited[i] == 0) 
    {
    r=r+1;
    q[r]=i; // insert them into queue
    visited[i]=1; // mark the vertex visited
    printf("%d ",i);
    }
    }
    f=f+1; // remove the vertex at front of the queue
    if(f&lt;=r) // as long as there are elements in the queue
    bfs(q[f]); // peform bfs again on the vertex at front of the queue
    }main()
    {
    int v,i,j;
    printf("\n Enter the number of vertices:");
    scanf("%d",&n);
    for (i=0;i&lt;n;i++) // mark all the vertices as not visited
    {
    visited[i]=0;
    }
    printf("\n Enter graph data in matrix form:\n");
    for (i=0;i&lt;n;i++)
    for (j=0;j&lt;n;j++)
    scanf("%d",&a[i][j]);
    printf("\n Enter the starting vertex:");
    scanf("%d",&v);
    f=r=0;
    q[r]=v;
    printf("\n BFS traversal is:\n");
    visited[v]=1; // mark the starting vertex as visited
    printf("%d ",v);
    bfs(v);
    if(r != n-1)
    printf("\n BFS is not possible");
    }
    

    DFS:
#include&lt;stdio.h>
void DFS(int);
int G[10][10],visited[10],n; //n is no of vertices and graph is sorted in array G[10][10]
void main()
{
int i,j;
printf("Enter number of vertices:");
scanf("%d",&n);
//read the adjecency matrix
printf("\nEnter adjecency matrix of the graph:");
for(i=0;i&lt;n;i++)
for(j=0;j&lt;n;j++)
scanf("%d",&G[i][j]);
//visited is initialized to zero
for(i=0;i&lt;n;i++)
visited[i]=0;
DFS(0);
}
void DFS(int i)
{
int j;
printf("\n%d",i);
visited[i]=1;
for(j=0;j&lt;n;j++)
if(!visited[j]&&G[i][j]==1)
DFS(j)
#include&lt;stdio.h>
void DFS(int);
int G[10][10],visited[10],n; //n is no of vertices and graph is sorted in array G[10][10]
void main()
{
int i,j;
printf("Enter number of vertices:");
scanf("%d",&n);
//read the adjecency matrix
printf("\nEnter adjecency matrix of the graph:");
for(i=0;i&lt;n;i++)
for(j=0;j&lt;n;j++)
scanf("%d",&G[i][j]);
//visited is initialized to zero
for(i=0;i&lt;n;i++)
visited[i]=0;
DFS(0);
}
void DFS(int i)
{
int j;
printf("\n%d",i);
visited[i]=1;
for(j=0;j&lt;n;j++)
if(!visited[j]&&G[i][j]==1)
DFS(j);
}

            </pre>
        </div>
        <div class="col-2">
            <pre>
    Algorithm Bsf
    1. Initialize visited[] as false (or 0).
    2. Create a queue q and enqueue source vertex.
    3. While q is not empty, dequeue an item from q and print it. If this item has never been printed before then print it
    3. While q is not empty do following steps.
       a. Dequeue an item from q and print it.
       b. Mark this dequeued item as visited.
       c. For every adjacent of dequeued item perform following steps.
       i. If this adjacent has not been visited then mark it visited and enqueue it.
       This way we ensure that all vertices are covered.

Algorithm for Depth First Search (DFS):

    Algorithm for DFS
    The steps involved in the DFS algorithm to explore a graph are given as follows -
    Step 1: Set visited array to false, where visited[i] indicates whether vertex i has been explored or not.
    Step 2: Call DFS recursively on an arbitrary chosen vertex v from the graph.
    Step 3: Mark the current vertex as visited by setting visited[v] = true.
    Step 4: Print the value of v.
    Step 5: For every adjacent u of v, if u is not visited then call DFS(u), else continue with next adjac
    Step 6: Backtrack from the last vertex reached by DFS and mark it as unvisited again.
    Step 7: Return back to the calling function.
    Step 8: If there is no more recursion stack, terminate the program.
    
            </pre>
        </div>

    </div>
    <hr>
</body>

</html>